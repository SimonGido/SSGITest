#include "/Engine/Public/Platform.ush"


RWTexture2D<float4> OutputTexture; // Output texture for downsampled result
Texture2D<float4> InputTexture; // Input texture to be downsampled
Texture2D<float> DepthTexture;

SamplerState InputSampler
{
    Filter = MIN_MAG_LINEAR_MIP_POINT; // Bilinear filtering
    AddressU = Wrap; // Wrap addressing mode in U direction
    AddressV = Wrap; // Wrap addressing mode in V direction
};

float2 ViewportSize;

float SigmaSpatial;
float SigmaIntensity;
float SigmaDepth;

int FilterSteps;

int Scale;
int Mode;

#define DOWNSAMPLE 0
#define UPSAMPLE 1

#define EPSILON 1.0e-4f

float3 DownsampleBox13(Texture2D<float4> tex, float lod, float2 uv, float2 texelSize)
{
    // Center
    float3 A = tex.SampleLevel(InputSampler, uv, lod).rgb;

    texelSize *= 0.5f; // Sample from center of texels

    // Inner box
    float3 B = tex.SampleLevel(InputSampler, uv + texelSize * float2(-1.0f, -1.0f), lod).rgb;
    float3 C = tex.SampleLevel(InputSampler, uv + texelSize * float2(-1.0f, 1.0f), lod).rgb;
    float3 D = tex.SampleLevel(InputSampler, uv + texelSize * float2(1.0f, 1.0f), lod).rgb;
    float3 E = tex.SampleLevel(InputSampler, uv + texelSize * float2(1.0f, -1.0f), lod).rgb;

    // Outer box
    float3 F = tex.SampleLevel(InputSampler, uv + texelSize * float2(-2.0f, -2.0f), lod).rgb;
    float3 G = tex.SampleLevel(InputSampler, uv + texelSize * float2(-2.0f, 0.0f), lod).rgb;
    float3 H = tex.SampleLevel(InputSampler, uv + texelSize * float2(0.0f, 2.0f), lod).rgb;
    float3 I = tex.SampleLevel(InputSampler, uv + texelSize * float2(2.0f, 2.0f), lod).rgb;
    float3 J = tex.SampleLevel(InputSampler, uv + texelSize * float2(2.0f, 2.0f), lod).rgb;
    float3 K = tex.SampleLevel(InputSampler, uv + texelSize * float2(2.0f, 0.0f), lod).rgb;
    float3 L = tex.SampleLevel(InputSampler, uv + texelSize * float2(-2.0f, -2.0f), lod).rgb;
    float3 M = tex.SampleLevel(InputSampler, uv + texelSize * float2(0.0f, -2.0f), lod).rgb;

    // Weights
    float3 result = float3(0.0, 0.0, 0.0);
    // Inner box
    result += (B + C + D + E) * 0.5f;
    // Bottom-left box
    result += (F + G + A + M) * 0.125f;
    // Top-left box
    result += (G + H + I + A) * 0.125f;
    // Top-right box
    result += (A + I + J + K) * 0.125f;
    // Bottom-right box
    result += (M + A + K + L) * 0.125f;

    // 4 samples each
    result *= 0.25f;

    return result;
}


float3 UpsampleTent9(Texture2D<float4> tex, float lod, float2 uv, float2 texelSize, float radius)
{
    float4 offset = texelSize.xyxy * float4(1.0f, 1.0f, -1.0f, 0.0f) * radius;

    // Center
    float3 result = tex.SampleLevel(InputSampler, uv, lod).rgb * 4.0f;

    result += tex.SampleLevel(InputSampler, uv - offset.xy, lod).rgb;
    result += tex.SampleLevel(InputSampler, uv - offset.wy, lod).rgb * 2.0;
    result += tex.SampleLevel(InputSampler, uv - offset.zy, lod).rgb;

    result += tex.SampleLevel(InputSampler, uv + offset.zw, lod).rgb * 2.0;
    result += tex.SampleLevel(InputSampler, uv + offset.xw, lod).rgb * 2.0;

    result += tex.SampleLevel(InputSampler, uv + offset.zy, lod).rgb;
    result += tex.SampleLevel(InputSampler, uv + offset.wy, lod).rgb * 2.0;
    result += tex.SampleLevel(InputSampler, uv + offset.xy, lod).rgb;

    return result * (1.0f / 16.0f);
}


float4 QuadraticThreshold(float4 color, float threshold, float3 curve)
{
    // Maximum pixel brightness
    float brightness = max(max(color.r, color.g), color.b);
    // Quadratic curve
    float rq = clamp(brightness - curve.x, 0.0, curve.y);
    rq = (rq * rq) * curve.z;
    color *= max(rq, brightness - threshold) / max(brightness, EPSILON);
    return color;
}


float Gaussian(float x, float sigma)
{
    return exp(-(x * x) / (2.0 * sigma * sigma));
}

float4 BilateralFilter(Texture2D<float4> tex, float2 uv, float4 centerColor, float depthCenter, float sigmaSpatial, float sigmaIntensity, float sigmaDepth)
{
    float4 filteredColor = float4(0.0, 0.0, 0.0, 0.0);
    float weightSum = 0.0;

    // Iterate over a square neighborhood
    for (int i = -FilterSteps; i <= FilterSteps; ++i)
    {
        for (int j = -FilterSteps; j <= FilterSteps; ++j)
        {
            float2 offsetUV = uv + (float2(i + 0.5, j + 0.5) / ViewportSize);

            // Sample color and depth of the neighboring pixel
            float4 neighborColor = tex.SampleLevel(InputSampler, offsetUV, 0);
            float neighborDepth = DepthTexture.SampleLevel(InputSampler, offsetUV, 0);

            // Calculate spatial and intensity differences
            float2 spatialDiff = offsetUV - uv;
            float spatialDist = length(spatialDiff);
            float intensityDiff = length(centerColor.rgb - neighborColor.rgb);
            float depthDiff = abs(depthCenter - neighborDepth);
            
            // Calculate bilateral filter weight
            float spatialWeight = Gaussian(spatialDist, sigmaSpatial);
            float intensityWeight = Gaussian(intensityDiff, sigmaIntensity);
            float depthWeight = Gaussian(depthDiff, sigmaDepth);
            float bilateralWeight = spatialWeight * intensityWeight * depthWeight;

            // Accumulate filtered color and weight
            filteredColor += neighborColor * bilateralWeight;
            weightSum += bilateralWeight;
        }
    }

    // Normalize filtered color by weight sum
    filteredColor /= weightSum;

    return filteredColor;
}


[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void Main(uint3 DTid : SV_DispatchThreadID)
{
    // Calculate the coordinates of the output pixel in the downsampled texture
    float2 texCoords = float2(DTid.xy) / ViewportSize;
    
    float4 color = float4(1, 0, 1, 1);
    if (Mode == DOWNSAMPLE)
    {
        color.rgb = DownsampleBox13(InputTexture, 0, texCoords, 1.0f / ViewportSize);
    }
    else if (Mode == UPSAMPLE)
    {
        color.rgb = UpsampleTent9(InputTexture, 0, texCoords, 1.0f / ViewportSize, 1.0f);   
        float depth = DepthTexture.SampleLevel(InputSampler, texCoords, 0);
        color = BilateralFilter(InputTexture, texCoords, color, depth, SigmaSpatial, SigmaIntensity, SigmaDepth);
        color.a = 1.0;
    }
    
    
    // Write the downsampled pixel value to the output texture
    OutputTexture[DTid.xy / Scale] = color;
}