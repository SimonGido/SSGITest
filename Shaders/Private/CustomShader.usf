#include "/Engine/Public/Platform.ush"

RWTexture2D<float4> OutputTexture;
Texture2D<float4> MainTexture;
Texture2D<float> DepthTexture;
SamplerState MainSampler;


float4x4 InverseProjectionMatrix;
float4 ViewportSize;
float4 Data; // SampleCount, IndirectAmount, NoiseAmount, Noise



float2 mod_dither3(float2 u)
{
    float noiseX = fmod(u.x + u.y + fmod(208. + u.x * 3.58, 13. + fmod(u.y * 22.9, 9.)), 7.) * .143;
    float noiseY = fmod(u.y + u.x + fmod(203. + u.y * 3.18, 12. + fmod(u.x * 27.4, 8.)), 6.) * .139;
    return float2(noiseX, noiseY) * 2.0 - 1.0;
}

float2 dither(float2 coord, float seed, float2 size)
{
    float noiseX = ((frac(1.0 - (coord.x + seed * 1.0) * (size.x / 2.0)) * 0.25) + (frac((coord.y + seed * 2.0) * (size.y / 2.0)) * 0.75)) * 2.0 - 1.0;
    float noiseY = ((frac(1.0 - (coord.x + seed * 3.0) * (size.x / 2.0)) * 0.75) + (frac((coord.y + seed * 4.0) * (size.y / 2.0)) * 0.25)) * 2.0 - 1.0;
    return float2(noiseX, noiseY);
}


float3 getViewPos(Texture2D<float> tex, float2 uv, float4x4 ipm)
{
    float depth = tex.SampleLevel(MainSampler, uv, 0);
 
    //Turn the current pixel from ndc to world coordinates
    float3 pixel_pos_ndc = float3(uv * 2.0 - 1.0, depth * 2.0 - 1.0);
   
    pixel_pos_ndc = float3(
        uv.x * 2.0 - 1.0,
        depth * 2.0 - 1.0,
        uv.y // In UE4 up is Z coordinate
    );
    // NOTE: it should be uv.y * 2.0 - 1.0 but for whatever reason it weirdly splits image in half
    float4 pixel_pos_clip = mul(ipm, float4(pixel_pos_ndc, 1.0));
    float3 pixel_pos_cam = pixel_pos_clip.xyz / pixel_pos_clip.w;
    return pixel_pos_cam;
}



float3 getViewNormal(Texture2D<float> tex, float2 uv, float4x4 ipm)
{
    float pW = 1.0 / ViewportSize.x;
    float pH = 1.0 / ViewportSize.y;

    float3 p1 = getViewPos(tex, uv + float2(pW, 0.0), ipm).xyz;
    float3 p2 = getViewPos(tex, uv + float2(0.0, pH), ipm).xyz;
    float3 p3 = getViewPos(tex, uv + float2(-pW, 0.0), ipm).xyz;
    float3 p4 = getViewPos(tex, uv + float2(0.0, -pH), ipm).xyz;

    float3 vP = getViewPos(tex, uv, ipm);

    float3 dx = vP - p1;
    float3 dy = p2 - vP;
    float3 dx2 = p3 - vP;
    float3 dy2 = vP - p4;
    
   
    if (length(dx2) < length(dx) && uv.x - pW >= 0.0 || uv.x + pW > 1.0)
    {
        dx = dx2;
    }

    if (length(dy2) < length(dy) && uv.y - pH >= 0.0 || uv.y + pH > 1.0)
    {
        dy = dy2;
    }

    return normalize(-cross(dx, dy).xyz);
}


float lenSq(float3 v)
{
    return pow(v.x, 2.0) + pow(v.y, 2.0) + pow(v.z, 2.0);
}

float3 lightSample(Texture2D<float4> color_tex, Texture2D<float> depth_tex, float2 uv, float4x4 ipm, float2 lightUV, float3 normal, float3 position, float n, float2 texsize)
{
    float2 random = float2(1.0, 1.0);
    int noise = int(Data.w);
    float noiseAmount = Data.z;
    
    if (noise > 0)
    {
        random = (mod_dither3((uv * texsize) + float2(n * 82.294, n * 127.721))) * 0.01 * noiseAmount;
    }
    else
    {
        random = dither(uv, 1.0, texsize) * 0.1 * noiseAmount;
    }
    float2 coord = uv * ViewportSize.xy;
    lightUV *= float2(0.7, 0.7);

    //light absolute data 
    float4 lightcolor = color_tex.SampleLevel(MainSampler, lightUV + random, 0);
    float3 lightnormal = getViewNormal(depth_tex, frac(lightUV) + random, ipm).rgb;
    float3 lightposition = getViewPos(depth_tex, frac(lightUV) + random, ipm).xyz;

                //light variable data
    float3 lightpath = lightposition - position;
    float3 lightdir = normalize(lightpath);

                //falloff calculations
    float cosemit = clamp(dot(lightdir, -lightnormal), 0.0, 1.0); //emit only in one direction
    float coscatch = clamp(dot(lightdir, normal) * 0.5 + 0.5, 0.0, 1.0); //recieve light from one direction
    float distfall = pow(lenSq(lightpath), 0.1) + 1.0; //fall off with distance

    return (lightcolor * cosemit * coscatch / distfall) * (length(lightposition) / 20.0);
}




[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void Main(uint3 Gid : SV_GroupID, //atm: -, 0...256, - in rows (Y)        --> current group index (dispatched by c++)
                       uint3 DTid : SV_DispatchThreadID, //atm: 0...256 in rows & columns (XY)   --> "global" thread id
                       uint3 GTid : SV_GroupThreadID, //atm: 0...256, -,- in columns (X)      --> current threadId in group / "local" threadId
                       uint GI : SV_GroupIndex)            //atm: 0...256 in columns (X)           --> "flattened" index of a thread within a group)
{

    float2 uv = float2(DTid.xy) / ViewportSize.xy;
    float4 direct = MainTexture.SampleLevel(MainSampler, uv, 0);

    float3 color = normalize(direct).rgb;
    float3 indirect = float3(0.0, 0.0, 0.0);
    float PI = 3.14159;
    float2 texSize = ViewportSize.xy;
    
    float3 position = getViewPos(DepthTexture, uv, InverseProjectionMatrix);
    float3 normal = getViewNormal(DepthTexture, uv, InverseProjectionMatrix);
   
    int samplesCount = int(Data.x);
    float indirectAmount = int(Data.y);
    
    float dlong = PI * (3.0 - sqrt(5.0));
    float dz = 1.0 / float(samplesCount);
    float l = 0.0;
    float z = 1.0 - dz / 2.0;

    for (int i = 0; i < samplesCount; i++)
    {
        float r = sqrt(1.0 - z);
    
        float xpoint = (cos(l) * r) * 0.5 + 0.5;
        float ypoint = (sin(l) * r) * 0.5 + 0.5;
    
        
        z = z - dz;
        l = l + dlong;
    
        indirect += lightSample(MainTexture, DepthTexture, uv, InverseProjectionMatrix, float2(xpoint, ypoint), normal, position, float(i), texSize);
    }
    float3 indirectColor = (indirect / float(samplesCount)) * indirectAmount;
    direct.rgb += indirectColor.rgb;
    
    //float depth = DepthTexture.SampleLevel(MainSampler, uv, 0);
    //direct.rgb = float3(depth, depth, depth);

    OutputTexture[DTid.xy] = float4(direct.rgb, direct.a);
}