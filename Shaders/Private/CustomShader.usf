#include "/Engine/Public/Platform.ush"

RWTexture2D<float4> OutputTexture;
Texture2D<float4>   ColorTexture;
Texture2D<float4>   NormalTexture;
Texture2D<float>    DepthTexture;


float4x4 InverseProjection;
float4x4 InverseView;
float4x4 Projection;
float4x4 View;
float2   ViewportSize;


float4 GetClipPosition(float2 coords, float depth)
{
    coords /= ViewportSize;
    return float4(coords.x * 2.0f - 1.0f, 1.0f - coords.y, depth, 1.0f);
}


float3 GetViewPos(float2 coords, float depth)
{
    float4 clipPosition = GetClipPosition(coords, depth);
    float4 target = mul(clipPosition, InverseProjection);
    float3 viewPos = target.xyz / target.w;
    
    return viewPos;
}

float4 GetPixelWorldPosition(float2 coords, float depth)
{
    float4 clipPosition = GetClipPosition(coords, depth);

    float3 target = GetViewPos(coords, depth);
    
    // Return the world space position by transforming the view space position by the inverse view matrix
    float4 worldPosition = mul(float4(target.xyz, 1.0f), InverseView);
    
    return worldPosition;
}

float IGN(float2 coord, int frameId)
{
	// magic values are found by experimentation
    coord += float(frameId) * (float2(47, 17) * 0.695f);

    float3 magic = float3(0.06711056f, 0.00583715f, 52.9829189f);
    
    //https://juejin.cn/post/6844903687505068045
    //vec3 magic = vec3( 12.9898, 78.233, 43758.5453123 );
    
    return frac(magic.z * frac(dot(coord, magic.xy)));
}




float3 GetPerpendicularVector(float3 vec)
{
    float3 absVector = abs(vec);
    float3 perpendicularVector;

    if (absVector.y >= 0.9f)
        perpendicularVector = float3(vec.z, vec.x, -vec.y);
    else
        perpendicularVector = float3(-vec.y, vec.z, vec.x);

    return normalize(perpendicularVector);
}

// Get a cosine-weighted random vector centered around a specified normal direction.
float3 GetCosHemisphereSample(float rand1, float rand2, float3 hitNorm)
{
	// Get 2 random numbers to select our sample with
    float2 randVal = float2(rand1, rand2);

	// Cosine weighted hemisphere sample from RNG
    float3 bitangent = GetPerpendicularVector(hitNorm);
    float3 tangent = cross(bitangent, hitNorm);
    float r = sqrt(randVal.x);
    float phi = 2.0f * 3.14159265f * randVal.y;

	// Get our cosine-weighted hemisphere lobe sample direction
    return tangent * (r * cos(phi).x) + bitangent * (r * sin(phi)) + hitNorm.xyz * sqrt(max(0.0, 1.0f - randVal.x));
}

float4 Raymarch(float3 viewPos, float3 dir, int stepCount, float stepSize, float depth)
{
    float3 pos = viewPos;
    float4 result = float4(0.0f, 0.0f, 0.0f, 0.0f);
    for (int step = 0; step < stepCount; step++)
    {
        pos += dir * stepSize;
        float sampledDepth = DepthTexture[int2(pos.xy)];
        if (sampledDepth < depth)
            return float4(pos, sampledDepth);
    }
    return result;
}



[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void Main(uint3 Gid : SV_GroupID, //atm: -, 0...256, - in rows (Y)        --> current group index (dispatched by c++)
                       uint3 DTid : SV_DispatchThreadID, //atm: 0...256 in rows & columns (XY)   --> "global" thread id
                       uint3 GTid : SV_GroupThreadID, //atm: 0...256, -,- in columns (X)      --> current threadId in group / "local" threadId
                       uint GI : SV_GroupIndex)            //atm: 0...256 in columns (X)           --> "flattened" index of a thread within a group)
{

    if (DTid.x >= int(ViewportSize.x) || DTid.y >= int(ViewportSize.y))
        return;
    
    int stepCount = 100;
    float stepSize = 1.0 / float(stepCount);
    
    
    float noise = IGN(float2(DTid.xy), DTid.x % 8); //Animated Interleaved Gradient Noise
    float depth = DepthTexture[DTid.xy];
    float3 worldPos = GetPixelWorldPosition(float2(DTid.xy), depth).xyz;
    float3 viewDir = normalize(GetCosHemisphereSample(noise, noise, NormalTexture[DTid.xy].xyz));
    float3 viewPos = GetViewPos(float2(DTid.xy), depth);
    float3 dir = normalize(mul(float4(viewDir, 1.0f), View)).xyz;
    dir = normalize(mul(float4(dir, 1.0), Projection)).xyz;
    
    float4 raymarchResult = Raymarch(viewPos, dir, stepCount, stepSize, depth);
    float4 sampledColor = ColorTexture[int2(raymarchResult.xy)];
    
    OutputTexture[DTid.xy] = NormalTexture[DTid.xy];
    OutputTexture[DTid.xy] = float4(viewDir, 1.0f);
    //OutputTexture[DTid.xy] = GetPixelWorldPosition(float2(DTid.xy), depth);
    OutputTexture[DTid.xy] = float4(dir, 1.0f);
    OutputTexture[DTid.xy] = ColorTexture[DTid.xy] + sampledColor;
}